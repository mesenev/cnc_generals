// This file isn't generated, but this comment is necessary to exclude it from analysis.
// <auto-generated/>

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Threading;
using Yuzu;
using Yuzu.Json;

namespace BenchmarkBrowser
{
	public class Benchmark
	{
#if !TANGERINE
		private const int FramesChunkCount = 25000;

		private readonly IEnvironment environment;
		private readonly IDataSource dataSource;
		private readonly Lime.Persistence persistence;
		private readonly Dictionary<string, BenchmarkStage> stages = new ();
		private readonly List<byte[]> chunks = new ();
		private Lime.TaskList monitoringTaskOwner;
		private Lime.Task monitoringTask;

		public int FrameCount { get; private set; }
		public TimeSpan MonitoringDuration { get; private set; }
		public Exception Exception { get; private set; }

		public Benchmark(IEnvironment environment, IDataSource dataSource)
		{
			this.environment = environment;
			this.dataSource = dataSource;
			persistence = CreatePersistence();
		}

		public Lime.Task Start(Lime.TaskList tasks, object tag = null)
		{
			Stop();
			monitoringTaskOwner = tasks;
			monitoringTask = tasks.Add(MonitoringTask, tag);
			return monitoringTask;
		}

		public void Stop()
		{
			monitoringTaskOwner?.Stop(t => t == monitoringTask);
			monitoringTaskOwner = null;
			monitoringTask = null;
		}

		public byte[] GetResult()
		{
			var stagesList = stages.Values.ToList();
			stagesList.Sort((lhs, rhs) => lhs.Index.CompareTo(rhs.Index));
			var benchmarkResult = new Result {
				Title = dataSource.GetBenchmarkTitle(),
				Version = environment.GetVersion(),
				Platform = Lime.Application.Platform.ToString(),
				DeviceName = environment.GetDeviceName(),
				RenderingBackend = Lime.Application.RenderingBackend.ToString(),
				Date = DateTime.Now,
				Duration = MonitoringDuration,
				Stages = stagesList,
				ZippedFrames = chunks,
			};
			return benchmarkResult.GetBytes(persistence);
		}

		private IEnumerator<object> MonitoringTask()
		{
			var stopwatch = new Stopwatch();
			FrameDataChunk chunk = null;
			StageInterval stageInterval = null;
			try {
				BenchmarkStage lastStage = null;
				chunk = new FrameDataChunk {
					Metrics = dataSource.CreateMetrics(),
				};
				while (true) {
					try {
						if (dataSource.IsFrameAccessible()) {
							if (!stopwatch.IsRunning) {
								stopwatch.Start();
							}

							BenchmarkStage stage;
							var stageName = dataSource.GetStageName();
							if (string.IsNullOrEmpty(stageName)) {
								throw new InvalidOperationException("Benchmark stage name can't be null or empty!");
							}
							if (lastStage?.Name == stageName) {
								stage = lastStage;
							} else {
								FinishStageInterval();
								if (!stages.TryGetValue(stageName, out stage)) {
									stages.Add(
										stageName,
										stage = new BenchmarkStage {
											Index = stages.Count,
											Name = stageName,
											Description = dataSource.GetStageDescription(),
										}
									);
								}
								stageInterval = new StageInterval {
									StageIndex = stage.Index,
									StartFrame = FrameCount + chunk.FrameCount,
								};
							}
							lastStage = stage;

							dataSource.AddFrameMetrics(chunk.Metrics);
							if (chunk.FrameCount >= FramesChunkCount) {
								ZipFrameChunk();
							}
						} else {
							dataSource.SkipFrame();
						}
					} catch (Exception exception) {
						Exception = exception;
					}
					if (Exception != null) {
						break;
					}
					yield return null;
				}
			} finally {
				stopwatch.Stop();
				MonitoringDuration = stopwatch.Elapsed;
				FinishStageInterval();
				if (chunk.FrameCount > 0) {
					ZipFrameChunk();
				}
				chunk = null;
			}

			void FinishStageInterval()
			{
				if (stageInterval != null) {
					stageInterval.FrameCount = FrameCount + chunk.FrameCount - stageInterval.StartFrame;
					chunk.StageIntervals.Add(stageInterval);
					stageInterval = null;
				}
			}

			void ZipFrameChunk()
			{
				var jsonChunk = PersistenceWriteToString(persistence, chunk);
				var zipChunk = Zip(jsonChunk, CompressionLevel.Optimal);
				chunks.Add(zipChunk);
				FrameCount += chunk.FrameCount;
				chunk.Clear();
			}
		}

		public sealed class RenderingMetrics : IDisposable
		{
			private readonly Lime.IWindow window;
			private readonly Stopwatch fpsStopwatch = new Stopwatch();
			private readonly Queue<TimeSpan> fpsQueue = new Queue<TimeSpan>();
			private int interlockedFps;
			private int interlockedDrawCalls;

			public int Fps => Volatile.Read(ref interlockedFps);
			public int DrawCalls => Volatile.Read(ref interlockedDrawCalls);

			public RenderingMetrics(Lime.IWindow window)
			{
				this.window = window;
				window.Rendering += UpdateRenderingMetrics;
			}

			private void UpdateRenderingMetrics()
			{
				if (!fpsStopwatch.IsRunning) {
					fpsStopwatch.Start();
				}
				var time = fpsStopwatch.Elapsed;
				fpsQueue.Enqueue(time);
				var timeLimit = time - TimeSpan.FromSeconds(1);
				while (fpsQueue.Peek() < timeLimit) {
					fpsQueue.Dequeue();
				}
				Volatile.Write(ref interlockedFps, fpsQueue.Count);
				Volatile.Write(ref interlockedDrawCalls, Lime.Renderer.DrawCalls);
			}

			public void Dispose()
			{
				window.Rendering -= UpdateRenderingMetrics;
			}
		}

		public sealed class MemoryMetrics : IDisposable
		{
			private volatile object memoryWatchDogContext;
			private long interlockedGcTotalMemory;

			public long GcTotalMemory => Volatile.Read(ref interlockedGcTotalMemory);

			public MemoryMetrics()
			{
				var savedContext = new object();
				memoryWatchDogContext = savedContext;

				new Thread(
					() => {
						while (savedContext == memoryWatchDogContext) {
							Thread.Sleep(1000 / 60);

							var gcTotalMemory = GC.GetTotalMemory(false);
							Volatile.Write(ref interlockedGcTotalMemory, gcTotalMemory);
						}
					}
				) {
					IsBackground = true,
				}.Start();
			}

			public void Dispose()
			{
				memoryWatchDogContext = null;
			}
		}
#endif // !TANGERINE

		public static Lime.Persistence CreatePersistence()
		{
			var yuzuCommonOptions = new CommonOptions {
				TagMode = TagMode.Aliases,
				AllowEmptyTypes = true,
				CheckForEmptyCollections = true,
			};
			var yuzuJsonOptions = new JsonSerializeOptions {
				ArrayLengthPrefix = false,
				Indent = string.Empty,
				FieldSeparator = string.Empty,
				SaveClass = JsonSaveClass.None,
				Unordered = true,
				MaxOnelineFields = 8,
				BOM = true,
				EnumAsString = true,
			};
			return new Lime.Persistence(yuzuCommonOptions, yuzuJsonOptions);
		}

		private static string PersistenceWriteToString<T>(Lime.Persistence persistence, T instance)
		{
			using var stream = new MemoryStream();
			persistence.WriteToStream(stream, instance, Lime.Persistence.Format.Json);
			using var reader = new StreamReader(stream);
			stream.Seek(0, SeekOrigin.Begin);
			return reader.ReadToEnd();
		}

		private static byte[] Zip(string str, CompressionLevel compressionLevel)
		{
			var bytes = Encoding.UTF8.GetBytes(str);
			using var msi = new MemoryStream(bytes);
			using var mso = new MemoryStream();
			using (var gs = new GZipStream(mso, compressionLevel)) {
				msi.CopyTo(gs);
			}
			return mso.ToArray();
		}

		public interface IEnvironment
		{
			string GetVersion();
			string GetDeviceName();
		}

		public interface IDataSource
		{
			void Activate();
			void Deactivate();
			string GetBenchmarkTitle();
			string GetBenchmarkFilePath();
			bool IsFrameAccessible();
			string GetStageName();
			string GetStageDescription();
			Metric[] CreateMetrics();
			void AddFrameMetrics(Metric[] metrics);
			void SkipFrame();
		}

#pragma warning disable 0649

		public class Result
		{
			[YuzuMember]
			public string Title;

			[YuzuMember]
			public string Version;

			[YuzuMember]
			public string Platform;

			[YuzuMember]
			public string DeviceName;

			[YuzuMember]
			public string RenderingBackend;

			[YuzuMember]
			public DateTime Date;

			[YuzuMember]
			public TimeSpan Duration;

			[YuzuMember]
			public List<BenchmarkStage> Stages = new List<BenchmarkStage>();

			[YuzuMember]
			public List<byte[]> ZippedFrames = new List<byte[]>();

#if TANGERINE
			public string FilePath;
			public Lime.Color4 Color;
			public FrameDataChunk EntireFrames;
			public FrameDataChunk FilteredFrames;

			public static Result Load(Lime.Persistence persistence, string filePath)
			{
				Result result;
				var zip = File.ReadAllBytes(filePath);
				var json = Unzip(zip);
				using (var stream = StringToStream(json)) {
					result = persistence.ReadFromStream<Result>(stream);
				}
				result.FilePath = filePath;
				foreach (var zipChunk in result.ZippedFrames) {
					var jsonChunk = Unzip(zipChunk);
					using var stream = StringToStream(jsonChunk);
					var chunk = persistence.ReadFromStream<FrameDataChunk>(stream);
					if (result.EntireFrames == null) {
						result.EntireFrames = chunk;
					} else {
						result.EntireFrames.Add(chunk);
					}
				}
				result.Validate();
				result.Process();
				return result;

				static string Unzip(byte[] bytes)
				{
					using var msi = new MemoryStream(bytes);
					using var mso = new MemoryStream();
					using (var gs = new GZipStream(msi, CompressionMode.Decompress)) {
						gs.CopyTo(mso);
					}
					return Encoding.UTF8.GetString(mso.ToArray());
				}

				static Stream StringToStream(string str)
				{
					var stream = new MemoryStream();
					var writer = new StreamWriter(stream);
					writer.Write(str);
					writer.Flush();
					stream.Position = 0;
					return stream;
				}
			}

			private void Validate()
			{
				Benchmark.StageInterval lastInterval = null;
				for (var i = 0; i < EntireFrames.StageIntervals.Count; i++) {
					var interval = EntireFrames.StageIntervals[i];
					if (interval.StageIndex < 0 || interval.StageIndex >= Stages.Count) {
						throw new InvalidDataException(
							$"Invalid stage interval at index {i}. There is no stage with index {interval.StageIndex}."
						);
					}
					var expectingStartFrame = lastInterval != null
						? lastInterval.StartFrame + lastInterval.FrameCount
						: 0;
					if (interval.StartFrame != expectingStartFrame) {
						throw new InvalidDataException(
							$"Invalid stage interval at index {i}. " +
							$"Stage interval starts with {interval.StartFrame} frame, expecting {expectingStartFrame}."
						);
					}
					if (interval.FrameCount <= 0) {
						throw new InvalidDataException(
							$"Invalid stage interval at index {i}. " +
							$"Stage interval's frame count can't be {interval.FrameCount}."
						);
					}
					var toFrame = interval.StartFrame + interval.FrameCount;
					if (toFrame > EntireFrames.FrameCount) {
						throw new InvalidDataException(
							$"Invalid stage interval at index {i}. Found range [{interval.StartFrame}..{toFrame}] " +
							$"for {EntireFrames.FrameCount} frames."
						);
					}
					lastInterval = interval;
				}
			}

			private void Process()
			{
				var frameTimeMetric = EntireFrames.Metrics.FirstOrDefault(m => m.Name == "Frame Time");
				if (frameTimeMetric != null) {
					foreach (var stageInterval in EntireFrames.StageIntervals) {
						var duration = 0d;
						var to = Math.Min(stageInterval.StartFrame + stageInterval.FrameCount + 1, frameTimeMetric.FrameCount);
						for (var i = stageInterval.StartFrame + 1; i < to; i++) {
							duration += frameTimeMetric.Values[i];
						}
						stageInterval.Duration = TimeSpan.FromMilliseconds(duration);
					}
				}
			}
#endif // TANGERINE

			public byte[] GetBytes() => GetBytes(CreatePersistence());

			public byte[] GetBytes(Lime.Persistence persistence)
			{
				var json = PersistenceWriteToString(persistence, this);
				return Zip(json, CompressionLevel.Optimal);
			}
		}

		public class BenchmarkStage
		{
#if !TANGERINE
			public int Index;
#endif // !TANGERINE

			[YuzuMember]
			public string Name;

			[YuzuMember]
			public string Description;

#if TANGERINE
			public BenchmarkStage SharedStage;

			public bool Enabled = true;
			public List<string> SplitedDescription { get; private set; }

			public void SplitDescription()
			{
				if (string.IsNullOrWhiteSpace(Description)) {
					return;
				}

				const int MaxPartLength = 100;
				SplitedDescription = new List<string>();
				var splitted = Description.Split(' ', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
				var stringBuilder = new StringBuilder(MaxPartLength);
				foreach (var part in splitted) {
					var s = part;
					var length = s.Length + (stringBuilder.Length > 0 ? 1 : 0);
					while (true) {
						if (stringBuilder.Length + length <= MaxPartLength) {
							if (stringBuilder.Length > 0) {
								stringBuilder.Append(' ');
							}
							stringBuilder.Append(s);
							break;
						}
						if (stringBuilder.Length == 0) {
							stringBuilder.Append(s, 0, MaxPartLength);
							s = s.Substring(MaxPartLength);
						}
						SplitedDescription.Add(stringBuilder.ToString());
						stringBuilder.Clear();
					}
				}
				if (stringBuilder.Length > 0) {
					SplitedDescription.Add(stringBuilder.ToString());
				}
			}

			public BenchmarkStage Clone()
			{
				return new BenchmarkStage {
					Name = Name,
					Description = Description,
				};
			}
#endif // TANGERINE
		}

		public class FrameDataChunk
		{
#if TANGERINE
			public FrameMeta[] FramesMeta;
#endif // TANGERINE

			[YuzuMember]
			public List<StageInterval> StageIntervals = new List<StageInterval>();

			[YuzuMember]
			public Metric[] Metrics;

			public int FrameCount => Metrics != null && Metrics.Length > 0 ? Metrics[0].FrameCount : 0;

#if !TANGERINE
			public void Clear()
			{
				StageIntervals.Clear();
				foreach (var metric in Metrics) {
					metric.Values.Clear();
				}
			}
#endif // !TANGERINE

#if TANGERINE
			public void Add(FrameDataChunk chunk)
			{
				StageIntervals.AddRange(chunk.StageIntervals);
				if (Metrics == null || Metrics.Length == 0 || chunk.Metrics == null || Metrics.Length != chunk.Metrics.Length) {
					throw new InvalidOperationException();
				}
				for (var i = 0; i < Metrics.Length; i++) {
					Metrics[i].Values.AddRange(chunk.Metrics[i].Values);
				}
			}

			public FrameDataChunk ApplyFilter()
			{
				var result = new FrameDataChunk {
					Metrics = new Metric[Metrics.Length],
				};
				var frameCount = 0;
				foreach (var stageInterval in StageIntervals) {
					if (stageInterval.SharedStage.Enabled) {
						result.StageIntervals.Add(stageInterval.Clone(startFrame: frameCount));
						frameCount += stageInterval.FrameCount;
					}
				}
				var frameMetaIndex = 0;
				result.FramesMeta = new FrameMeta[frameCount];
				foreach (var stageInterval in StageIntervals) {
					if (stageInterval.SharedStage.Enabled) {
						var to = stageInterval.StartFrame + stageInterval.FrameCount;
						for (var j = stageInterval.StartFrame; j < to; j++) {
							result.FramesMeta[frameMetaIndex++] = FramesMeta[j];
						}
					}
				}
				for (var i = 0; i < Metrics.Length; i++) {
					var metric = Metrics[i];
					var newMetric = metric.CloneWithoutValues();
					newMetric.Values = new List<double>(frameCount);
					foreach (var stageInterval in StageIntervals) {
						if (stageInterval.SharedStage.Enabled) {
							var to = stageInterval.StartFrame + stageInterval.FrameCount;
							for (var j = stageInterval.StartFrame; j < to; j++) {
								newMetric.Values.Add(metric.Values[j]);
							}
						}
					}
					result.Metrics[i] = newMetric;
				}
				return result;
			}

			public void CalculateMetricMeasures()
			{
				foreach (var metric in Metrics) {
					metric.Sum = 0;
					metric.SortedValues = new double[FrameCount];
					if (FrameCount == 0) {
						metric.Min = 0;
						metric.Max = 0;
						continue;
					}

					var i = 0;
					foreach (var stageInterval in StageIntervals) {
						var to = stageInterval.StartFrame + stageInterval.FrameCount;
						for (var j = stageInterval.StartFrame; j < to; j++) {
							var value = metric.Values[j];
							metric.SortedValues[i++] = value;
							metric.Sum += value;
						}
					}
					Array.Sort(metric.SortedValues);
					metric.Min = metric.SortedValues[0];
					metric.Max = metric.SortedValues[^1];
				}
			}
#endif // TANGERINE
		}

#if TANGERINE
		public class FrameMeta
		{
			public readonly int Index;
			public readonly BenchmarkStage SharedStage;

			public FrameMeta(int index, BenchmarkStage sharedStage)
			{
				Index = index;
				SharedStage = sharedStage;
			}
		}
#endif // TANGERINE

		public class StageInterval
		{
			[YuzuMember]
			public int StartFrame;

			[YuzuMember]
			public int FrameCount;

			[YuzuMember]
			public int StageIndex;

#if TANGERINE
			public BenchmarkStage SharedStage;
			public TimeSpan Duration = TimeSpan.MinValue;

			public StageInterval Clone(int startFrame = -1)
			{
				return new StageInterval {
					StartFrame = startFrame < 0 ? StartFrame : startFrame,
					FrameCount = FrameCount,
					StageIndex = StageIndex,
					SharedStage = SharedStage,
					Duration = Duration,
				};
			}
#endif // TANGERINE
		}

		public class Metric
		{
			private static readonly float[] defaultHistogramProcentiles = new[] { 1f, 0.75f, 0.5f };

			[YuzuMember]
			public string Name;

			[YuzuMember]
			public int Precision;

			[YuzuMember]
			public ChartValueMergerMode ChartValueMergerMode = ChartValueMergerMode.Maximum;

			[YuzuMember]
			public ChartMinReference ChartMinReference;

			[YuzuMember]
			public int ChartDefaultRange = 100;

			[YuzuMember]
			public double[] ChartReferentialValues = new double[0];

			[YuzuMember]
			public float[] HistogramProcentiles = defaultHistogramProcentiles;

			[YuzuMember]
			public List<double> Values;

			public int FrameCount => Values.Count;

#if TANGERINE
			public double[] SortedValues;
			public double Sum;
			public double Min;
			public double Max;

			public double GetProcentile(float procentile)
			{
				if (procentile < 0 || procentile > 1) {
					throw new ArgumentOutOfRangeException(nameof(procentile), procentile, null);
				}
				if (SortedValues.Length == 0) {
					return 0;
				}
				var i = (int)Math.Round((SortedValues.Length - 1) * procentile);
				return SortedValues[i];
			}
#endif // TANGERINE

			public Metric() { }

			public Metric(
				string name,
				int precision = 0,
				ChartValueMergerMode chartValueMergerMode = ChartValueMergerMode.Maximum,
				ChartMinReference chartMinReference = default,
				int chartDefautRange = 100,
				double[] chartReferentialValues = null,
				float[] histogramProcentiles = null
			) {
				Name = name;
				Precision = precision;
				ChartValueMergerMode = chartValueMergerMode;
				ChartMinReference = chartMinReference;
				ChartDefaultRange = chartDefautRange;
				if (chartReferentialValues != null) {
					ChartReferentialValues = chartReferentialValues;
				}
				HistogramProcentiles = histogramProcentiles ?? defaultHistogramProcentiles;
#if !TANGERINE
				Values = new List<double>(FramesChunkCount);
#endif // TANGERINE
			}

			public Metric CloneWithoutValues()
			{
				return new Metric(
					Name,
					Precision,
					ChartValueMergerMode,
					ChartMinReference,
					ChartDefaultRange,
					ChartReferentialValues,
					HistogramProcentiles
				);
			}
		}

		public enum ChartMinReference
		{
			Zero,
			MinValue,
		}

		public enum ChartValueMergerMode
		{
			Minimum,
			Maximum,
		}

#pragma warning restore 0649
	}
}
